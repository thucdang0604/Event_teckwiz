import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'unified_notification_service.dart';
import 'notification_service.dart';

class MultilangNotificationService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final UnifiedNotificationService _unifiedNotificationService =
      UnifiedNotificationService();

  static const String _translationsCollection = 'notification_translations';
  static const String _userLanguagesCollection = 'user_languages';

  // Supported languages
  static const List<String> supportedLanguages = [
    'vi', // Vietnamese
    'en', // English
    'zh', // Chinese
    'ja', // Japanese
    'ko', // Korean
    'th', // Thai
    'id', // Indonesian
    'ms', // Malay
  ];

  static const String defaultLanguage = 'vi';

  // L∆∞u translation
  Future<void> saveTranslation({
    required String key,
    required String language,
    required String translation,
    required String category,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      await _firestore
          .collection(_translationsCollection)
          .doc('${key}_$language')
          .set({
            'key': key,
            'language': language,
            'translation': translation,
            'category': category,
            'metadata': metadata ?? {},
            'createdAt': Timestamp.fromDate(DateTime.now()),
            'updatedAt': Timestamp.fromDate(DateTime.now()),
          });

      print('‚úÖ Translation saved: $key ($language)');
    } catch (e) {
      print('‚ùå Error saving translation: $e');
      throw Exception('Failed to save translation: $e');
    }
  }

  // L·∫•y translation
  Future<String?> getTranslation({
    required String key,
    required String language,
  }) async {
    try {
      final doc = await _firestore
          .collection(_translationsCollection)
          .doc('${key}_$language')
          .get();

      if (doc.exists) {
        return doc.data()?['translation'] as String?;
      }
      return null;
    } catch (e) {
      print('‚ùå Error getting translation: $e');
      return null;
    }
  }

  // L·∫•y t·∫•t c·∫£ translations cho m·ªôt key
  Future<Map<String, String>> getTranslationsForKey(String key) async {
    try {
      final snapshot = await _firestore
          .collection(_translationsCollection)
          .where('key', isEqualTo: key)
          .get();

      Map<String, String> translations = {};

      for (final doc in snapshot.docs) {
        final data = doc.data();
        final language = data['language'] as String;
        final translation = data['translation'] as String;
        translations[language] = translation;
      }

      return translations;
    } catch (e) {
      print('‚ùå Error getting translations for key: $e');
      return {};
    }
  }

  // L·∫•y user language preference
  Future<String> getUserLanguage(String userId) async {
    try {
      final doc = await _firestore
          .collection(_userLanguagesCollection)
          .doc(userId)
          .get();

      if (doc.exists) {
        return doc.data()?['language'] as String? ?? defaultLanguage;
      }

      // T·∫°o default language preference
      await _firestore.collection(_userLanguagesCollection).doc(userId).set({
        'userId': userId,
        'language': defaultLanguage,
        'createdAt': Timestamp.fromDate(DateTime.now()),
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      });

      return defaultLanguage;
    } catch (e) {
      print('‚ùå Error getting user language: $e');
      return defaultLanguage;
    }
  }

  // C·∫≠p nh·∫≠t user language preference
  Future<void> updateUserLanguage(String userId, String language) async {
    try {
      if (!supportedLanguages.contains(language)) {
        throw Exception('Unsupported language: $language');
      }

      await _firestore.collection(_userLanguagesCollection).doc(userId).set({
        'userId': userId,
        'language': language,
        'updatedAt': Timestamp.fromDate(DateTime.now()),
      }, SetOptions(merge: true));

      print('‚úÖ User language updated: $userId -> $language');
    } catch (e) {
      print('‚ùå Error updating user language: $e');
      throw Exception('Failed to update user language: $e');
    }
  }

  // G·ª≠i notification ƒëa ng√¥n ng·ªØ
  Future<bool> sendMultilangNotification({
    required String userId,
    required String titleKey,
    required String bodyKey,
    required NotificationType type,
    Map<String, dynamic>? data,
    NotificationPriority priority = NotificationPriority.normal,
    String? language,
  }) async {
    try {
      // L·∫•y language c·ªßa user
      final userLanguage = language ?? await getUserLanguage(userId);

      // L·∫•y translations
      final titleTranslation = await getTranslation(
        key: titleKey,
        language: userLanguage,
      );

      final bodyTranslation = await getTranslation(
        key: bodyKey,
        language: userLanguage,
      );

      // Fallback to default language if translation not found
      final title =
          titleTranslation ??
          await getTranslation(key: titleKey, language: defaultLanguage) ??
          titleKey;

      final body =
          bodyTranslation ??
          await getTranslation(key: bodyKey, language: defaultLanguage) ??
          bodyKey;

      // G·ª≠i notification
      return await _unifiedNotificationService.sendUnifiedNotification(
        userId: userId,
        title: title,
        body: body,
        type: type,
        data: {
          ...?data,
          'language': userLanguage,
          'titleKey': titleKey,
          'bodyKey': bodyKey,
        },
        priority: priority,
      );
    } catch (e) {
      print('‚ùå Error sending multilang notification: $e');
      return false;
    }
  }

  // G·ª≠i bulk notification ƒëa ng√¥n ng·ªØ
  Future<Map<String, int>> sendBulkMultilangNotification({
    required List<String> userIds,
    required String titleKey,
    required String bodyKey,
    required NotificationType type,
    Map<String, dynamic>? data,
    NotificationPriority priority = NotificationPriority.normal,
  }) async {
    int successCount = 0;
    int failCount = 0;

    for (final userId in userIds) {
      try {
        final success = await sendMultilangNotification(
          userId: userId,
          titleKey: titleKey,
          bodyKey: bodyKey,
          type: type,
          data: data,
          priority: priority,
        );

        if (success) {
          successCount++;
        } else {
          failCount++;
        }
      } catch (e) {
        print('‚ùå Error sending multilang notification to $userId: $e');
        failCount++;
      }
    }

    print(
      'üìä Bulk multilang notification results: $successCount success, $failCount failed',
    );
    return {'success': successCount, 'failed': failCount};
  }

  // L·∫•y t·∫•t c·∫£ translations cho m·ªôt category
  Future<Map<String, Map<String, String>>> getTranslationsByCategory(
    String category,
  ) async {
    try {
      final snapshot = await _firestore
          .collection(_translationsCollection)
          .where('category', isEqualTo: category)
          .get();

      Map<String, Map<String, String>> translations = {};

      for (final doc in snapshot.docs) {
        final data = doc.data();
        final key = data['key'] as String;
        final language = data['language'] as String;
        final translation = data['translation'] as String;

        translations.putIfAbsent(key, () => {})[language] = translation;
      }

      return translations;
    } catch (e) {
      print('‚ùå Error getting translations by category: $e');
      return {};
    }
  }

  // L·∫•y missing translations
  Future<Map<String, List<String>>> getMissingTranslations() async {
    try {
      Map<String, List<String>> missing = {};

      for (final language in supportedLanguages) {
        final snapshot = await _firestore
            .collection(_translationsCollection)
            .where('language', isEqualTo: language)
            .get();

        final existingKeys = snapshot.docs
            .map((doc) => doc.data()['key'] as String)
            .toSet();

        // L·∫•y t·∫•t c·∫£ keys t·ª´ default language
        final defaultSnapshot = await _firestore
            .collection(_translationsCollection)
            .where('language', isEqualTo: defaultLanguage)
            .get();

        final allKeys = defaultSnapshot.docs
            .map((doc) => doc.data()['key'] as String)
            .toSet();

        final missingKeys = allKeys.difference(existingKeys).toList();
        if (missingKeys.isNotEmpty) {
          missing[language] = missingKeys;
        }
      }

      return missing;
    } catch (e) {
      print('‚ùå Error getting missing translations: $e');
      return {};
    }
  }

  // T·∫°o default translations
  Future<void> createDefaultTranslations() async {
    try {
      final defaultTranslations = {
        'notification.event_created.title': {
          'vi': 'S·ª± ki·ªán m·ªõi',
          'en': 'New Event',
          'zh': 'Êñ∞Ê¥ªÂä®',
          'ja': 'Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà',
          'ko': 'ÏÉà Ïù¥Î≤§Ìä∏',
          'th': '‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÉ‡∏´‡∏°‡πà',
          'id': 'Acara Baru',
          'ms': 'Acara Baru',
        },
        'notification.event_created.body': {
          'vi': 'C√≥ s·ª± ki·ªán m·ªõi: {{eventTitle}}',
          'en': 'New event available: {{eventTitle}}',
          'zh': 'Êñ∞Ê¥ªÂä®ÂèØÁî®Ôºö{{eventTitle}}',
          'ja': 'Êñ∞„Åó„ÅÑ„Ç§„Éô„É≥„Éà„ÅåÂà©Áî®ÂèØËÉΩÔºö{{eventTitle}}',
          'ko': 'ÏÉà Ïù¥Î≤§Ìä∏ ÏÇ¨Ïö© Í∞ÄÎä•Ôºö{{eventTitle}}',
          'th': '‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÉ‡∏´‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ôÔºö{{eventTitle}}',
          'id': 'Acara baru tersediaÔºö{{eventTitle}}',
          'ms': 'Acara baru tersediaÔºö{{eventTitle}}',
        },
        'notification.event_reminder.title': {
          'vi': 'Nh·∫Øc nh·ªü s·ª± ki·ªán',
          'en': 'Event Reminder',
          'zh': 'Ê¥ªÂä®ÊèêÈÜí',
          'ja': '„Ç§„Éô„É≥„Éà„É™„Éû„Ç§„É≥„ÉÄ„Éº',
          'ko': 'Ïù¥Î≤§Ìä∏ ÏïåÎ¶º',
          'th': '‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°',
          'id': 'Pengingat Acara',
          'ms': 'Peringatan Acara',
        },
        'notification.event_reminder.body': {
          'vi': 'S·ª± ki·ªán {{eventTitle}} s·∫Ω di·ªÖn ra trong {{timeRemaining}}',
          'en': 'Event {{eventTitle}} will start in {{timeRemaining}}',
          'zh': 'Ê¥ªÂä®{{eventTitle}}Â∞ÜÂú®{{timeRemaining}}ÂêéÂºÄÂßã',
          'ja': '„Ç§„Éô„É≥„Éà{{eventTitle}}„ÅØ{{timeRemaining}}Âæå„Å´ÈñãÂßã„Åï„Çå„Åæ„Åô',
          'ko': 'Ïù¥Î≤§Ìä∏{{eventTitle}}Ïù¥(Í∞Ä) {{timeRemaining}} ÌõÑÏóê ÏãúÏûëÎê©ÎãàÎã§',
          'th': '‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°{{eventTitle}}‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ô{{timeRemaining}}',
          'id': 'Acara {{eventTitle}} akan dimulai dalam {{timeRemaining}}',
          'ms': 'Acara {{eventTitle}} akan bermula dalam {{timeRemaining}}',
        },
        'notification.registration_confirmed.title': {
          'vi': 'ƒêƒÉng k√Ω ƒë∆∞·ª£c x√°c nh·∫≠n',
          'en': 'Registration Confirmed',
          'zh': 'Ê≥®ÂÜåÂ∑≤Á°ÆËÆ§',
          'ja': 'ÁôªÈå≤Á¢∫Ë™çÊ∏à„Åø',
          'ko': 'Îì±Î°ù ÌôïÏù∏Îê®',
          'th': '‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô',
          'id': 'Pendaftaran Dikonfirmasi',
          'ms': 'Pendaftaran Disahkan',
        },
        'notification.registration_confirmed.body': {
          'vi': 'ƒêƒÉng k√Ω tham gia s·ª± ki·ªán {{eventTitle}} ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n',
          'en': 'Your registration for {{eventTitle}} has been confirmed',
          'zh': 'ÊÇ®ÂØπ{{eventTitle}}ÁöÑÊ≥®ÂÜåÂ∑≤Á°ÆËÆ§',
          'ja': '{{eventTitle}}„Å∏„ÅÆÁôªÈå≤„ÅåÁ¢∫Ë™ç„Åï„Çå„Åæ„Åó„Åü',
          'ko': '{{eventTitle}}Ïóê ÎåÄÌïú Îì±Î°ùÏù¥ ÌôïÏù∏ÎêòÏóàÏäµÎãàÎã§',
          'th': '‡∏Å‡∏≤‡∏£‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö{{eventTitle}}‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
          'id': 'Pendaftaran Anda untuk {{eventTitle}} telah dikonfirmasi',
          'ms': 'Pendaftaran anda untuk {{eventTitle}} telah disahkan',
        },
      };

      for (final entry in defaultTranslations.entries) {
        final key = entry.key;
        final translations = entry.value;

        for (final langEntry in translations.entries) {
          final language = langEntry.key;
          final translation = langEntry.value;

          await saveTranslation(
            key: key,
            language: language,
            translation: translation,
            category: 'notification',
            metadata: {'isDefault': true, 'createdBy': 'system'},
          );
        }
      }

      print('‚úÖ Default translations created');
    } catch (e) {
      print('‚ùå Error creating default translations: $e');
    }
  }

  // L·∫•y language statistics
  Future<Map<String, dynamic>> getLanguageStatistics() async {
    try {
      final snapshot = await _firestore
          .collection(_userLanguagesCollection)
          .get();

      Map<String, int> languageCounts = {};
      int totalUsers = snapshot.docs.length;

      for (final doc in snapshot.docs) {
        final language = doc.data()['language'] as String? ?? defaultLanguage;
        languageCounts[language] = (languageCounts[language] ?? 0) + 1;
      }

      Map<String, double> languagePercentages = {};
      languageCounts.forEach((language, count) {
        languagePercentages[language] = totalUsers > 0
            ? (count / totalUsers * 100)
            : 0.0;
      });

      return {
        'totalUsers': totalUsers,
        'languageCounts': languageCounts,
        'languagePercentages': languagePercentages,
        'supportedLanguages': supportedLanguages,
        'defaultLanguage': defaultLanguage,
      };
    } catch (e) {
      print('‚ùå Error getting language statistics: $e');
      return {};
    }
  }

  // L·∫•y translation coverage
  Future<Map<String, dynamic>> getTranslationCoverage() async {
    try {
      Map<String, Map<String, int>> coverage = {};

      for (final language in supportedLanguages) {
        final snapshot = await _firestore
            .collection(_translationsCollection)
            .where('language', isEqualTo: language)
            .get();

        Map<String, int> categoryCounts = {};

        for (final doc in snapshot.docs) {
          final category = doc.data()['category'] as String;
          categoryCounts[category] = (categoryCounts[category] ?? 0) + 1;
        }

        coverage[language] = categoryCounts;
      }

      return {'coverage': coverage, 'supportedLanguages': supportedLanguages};
    } catch (e) {
      print('‚ùå Error getting translation coverage: $e');
      return {};
    }
  }

  // Auto-translate (placeholder - would integrate with translation API)
  Future<String?> autoTranslate({
    required String text,
    required String fromLanguage,
    required String toLanguage,
  }) async {
    // This would integrate with a translation service like Google Translate API
    // For now, return null to indicate manual translation needed
    print(
      'üîÑ Auto-translation not implemented yet: $text ($fromLanguage -> $toLanguage)',
    );
    return null;
  }

  // Validate translation completeness
  Future<Map<String, dynamic>> validateTranslations() async {
    try {
      final missingTranslations = await getMissingTranslations();
      final coverage = await getTranslationCoverage();

      int totalMissing = missingTranslations.values
          .map((list) => list.length)
          .reduce((a, b) => a + b);

      return {
        'missingTranslations': missingTranslations,
        'coverage': coverage,
        'totalMissing': totalMissing,
        'isComplete': totalMissing == 0,
      };
    } catch (e) {
      print('‚ùå Error validating translations: $e');
      return {};
    }
  }
}
